!use <abstract>.

int natural = 1...
int natural* = 0...

index_t ~ natural*.

-- locks
!lock natural.
!lock natural*.
!lock index_t.

*-- Read docs at /docs/builtin.md#integer-add
```a + b = c;
+(a, b) = c;``` 
--*
: ?+(int, int) -> int.

*-- Read docs at /docs/builtin.md#integer-subtract
```a - b = c;
-(a, b) = c;```
--*
: ?-(int, int) -> int.

-- Multiplication predicate
: ?*(int, int) -> int.

-- Integer division predicate
: ?/(int, int) -> int.

*-- `Greater than` constraint
can be applied on:
* `integers`
* `atoms` --*
: #>('T', 'T').
!"T:>"=int.

*-- `Less than` constraint
can be applied on:
* `integers`
* `atoms` --*
: #<('T', 'T').
!"T:<"=int.

#[int, @]:>(x, y) {__>(x, y)}
#[int, @]:<(x, y) {__>(y, x)}

: #>=('T', 'T').
!"T:>="=int.
#[int, @]:>=(x, y) when x __gte y.

: #<=('T', 'T').
!"T:<="=int.
#[int, @]:<=(x, y) when y >= x.

?+(x, y) -> x __+ y.
?-(y + z, y) -> z.
?*(x, y) -> x __* y.
?/(x * y, y) -> x.

-- math `sqrt` predicate
: ?sqrt(int) -> int.
?sqrt(0) -> 0.
?sqrt(1) -> 1.
?sqrt(x) -> __sqrt(x).

-- Plus-minus predicate.
-- ```x = (-b +- sqrt(D)) / (2 * a)```
: ?+-(int, int) -> int.

?+-(x, y) -> z {
    z = x + y;
}

?+-(x, y) -> z {
    z = x - y;
}

-- Integer pow predicate
!ordering.
: ?pow(int, int) -> int.
?pow(x, 0) -> 1.
?pow(x, 1) -> x.

?pow(Value, Pow) -> R {
    Pow > 1;
    Value?;
    R = Value * pow(Value, Pow - 1);
}

-- Absolute value predicate
-- absolute of -5 = 5
: ?absolute(int) -> int.
?absolute(x) -> x when x __gte 0.
?absolute(x) -> -x when x < 0.

-- Integer pow predicate (shortcut to `pow`)
: ?^(int, int) -> int.
?^(v, p) -> pow(v, p).

-- Always failing predicate
: ?fail().

-- Simple constraint
: #never('T', 'T').
#never(a, b) {
    a = b -> fail();
}

-- Message predicate working with stdio
: ?message(string).
?message(m) when __message(m).

-- between (boundaries secluded)
: #between(int, int) -> int.
#between(a, b) -> c when c > a, c < b.

*-- between (boundaries included).
`x = 0 .. 4`
`5 = 0 .. 4 -> fail()` --*
: #..(int, int) -> int.
#..(a, b) -> c when c >= a, c <= b.

cons ~ never.

: ?format(formatting) -> string.
?format(fmt) -> __format(fmt).

: ?-->('T', 'T'[]).
?-->(from, to) when __bag(from, to).

: ?<--('T'[], 'T').
?<--(to, from) when __bag(from, to).

: ?bagof('T') -> 'T'[].
?bagof(from) -> to when __bag(from, to).

: ?sized_bagof(natural, 'T') -> 'T'[].
?sized_bagof(size, from) -> to when
    __bag_sz(from, to, size).

-- working with arrays
: ?by_idx('T'[], int) -> 'T',
  ?append('T'[], 'T'[]) -> 'T'[].

?by_idx(arr, idx) -> __by_idx(arr, idx).
?append(arr, tail) -> __append(arr, tail).

-- predicate states that there are no 
-- nearby standing equal elements in array
: ?no_repeat('T'[]).

?no_repeat([]).
?no_repeat(arr) when length of arr = 1, arr?.

?no_repeat(arr) {
    i > 0;
    len = length of arr;
    len > 1;
    arr?;
    i < len;
    &all i {
        arr[i] never arr[i - 1];
    };
}

: ?all_distinct('T'[]).
?all_distinct([]).
?all_distinct([H|T]) {
    H in T -> fail();
    all_distinct(T);
}

*-- links array head to array tail
`linked{int}(1, [2,3]) = x`
`linked{int}(1, tail) = [1,2,3]` --*
: ?linked('T', 'T'[]) -> 'T'[].

?linked(head, tail) -> arr {
    arr[0] = head;
    append([head], tail) = arr;
}

-- flattens array to one dimension
-- `flatten{int}([[1,2], [], [3], [4, 5]]) = x`
!ordering.
: ?flatten('T'[]) -> 'T'.

?flatten([]) -> [].
?flatten([x]) -> x.

?flatten(array) -> flattened {
    linked(head, tail) = array;
    flattened = head:append(tail:flatten());
}

: ?in('T', 'T'[]).
?in(x, arr) when
    arr[_] = x.

__rounding ~ @{down, up}.

: ?sqrtu(int) -> int.
?sqrtu(n) -> x {
    __rounding r = @up;
    x = __sqrt_round(n, r);
}

: ?sqrtd(int) -> int.
?sqrtd(n) -> x {
    __rounding r = @down;
    x = __sqrt_round(n, r);
}

: ?map('T'[], (?('T') -> 'R')) -> 'R'[].
?map(seq, mapping) -> mseq {
    __map(seq, mapping) = mseq;
}

$ divmod_t {
    int div;
    int mod;
}

-- `X / Y = R + Mod`
: ?divmod(int, int) -> divmod_t.
?divmod(x, y) -> dm {
    __*mod(a, y, r) = x;
    dm = (a, r);
}

: ?/_(int, int) -> int.
?/_(x, y) -> z {
    divmod(x, y) = dm;
    dm = (z, _);
}

: ?from('T'[], index_t) -> 'T'[].
?from(arr, 0) -> arr.
?from(arr, n) -> tail {
    n = between(0, length(arr))?;
    T = abstract_primitive(arr);
    s ~ T[n];
    append(s, tail) = arr;
}

: ?to('T'[], index_t) -> 'T'[].
?to(arr, 0) -> [].
?to(arr, n) -> tail {
    n = ..(1, length(arr))?;
    T = abstract_primitive(arr);
    s ~ T[n];
    append(s, _) = arr;
    tail = s;
}

: ?slice('T'[], index_t, index_t) -> 'T'[].
?slice(arr, f, t) -> s {
    s = (arr from f) to t - f;
}

: ?max_of_two(int, int) -> int.
?max_of_two(a, b) -> a when a >= b.
?max_of_two(a, b) -> b when b > a.

: ?min_of_two(int, int) -> int.
?min_of_two(a, b) -> a when max_of_two(a, b) = b.
?min_of_two(a, b) -> b when max_of_two(a, b) = a.

: ?choose_one('T'[], (?('T', 'T') -> 'T')) -> 'T'.
?choose_one(arr, _) -> arr[0] when 
    length(arr) = 1.
?choose_one(arr, choose) -> choose(arr[0], arr[1]) when 
    length(arr) = 2.
?choose_one(arr, choose) -> x {
    a = arr[0];
    b = arr[1];
    t = from(arr, 2);
    x = choose(choose(a, b), choose_one(t, choose));
}

-- array to its maximum value
: ?max(int[]) -> int.
?max(arr) -> choose_one(arr, max_of_two).

-- array to its minumum value
: ?min(int[]) -> int.
?min(arr) -> choose_one(arr, min_of_two).